<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>File: README.fr.rdoc [RDoc Documentation]</title>

	<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet" />

	<script src="./js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>
</head>

<body class="file">
	<div id="metadata">
		<div id="home-metadata">
			<div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
			</div>
		</div>

		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="./README_de_rdoc.html">README.de.rdoc</a></li>
				
					<li class="file"><a href="./README_es_rdoc.html">README.es.rdoc</a></li>
				
					<li class="file"><a href="./README_fr_rdoc.html">README.fr.rdoc</a></li>
				
					<li class="file"><a href="./README_hu_rdoc.html">README.hu.rdoc</a></li>
				
					<li class="file"><a href="./README_rdoc.html">README.rdoc</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="./images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="./Sinatra.html">Sinatra</a></li>
				
					<li><a href="./Sinatra/Application.html">Sinatra::Application</a></li>
				
					<li><a href="./Sinatra/Base.html">Sinatra::Base</a></li>
				
					<li><a href="./Sinatra/Helpers.html">Sinatra::Helpers</a></li>
				
					<li><a href="./Sinatra/Request.html">Sinatra::Request</a></li>
				
					<li><a href="./Sinatra/Response.html">Sinatra::Response</a></li>
				
					<li><a href="./Sinatra/ShowExceptions.html">Sinatra::ShowExceptions</a></li>
				
					<li><a href="./Sinatra/Templates.html">Sinatra::Templates</a></li>
				
					<li><a href="./Sinatra/Templates/ContentTyped.html">Sinatra::Templates::ContentTyped</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1><a href="Sinatra.html">Sinatra</a></h1>
<p>
<em>Attention: Ce document correspond à la traduction de la version
anglaise et il n&#8217;est peut être plus à jour.</em>
</p>
<p>
<a href="Sinatra.html">Sinatra</a> est un DSL pour créer rapidement des
applications web en Ruby et sans effort:
</p>
<pre>
  # mon_application.rb
  require 'sinatra'
  get '/' do
    'Bonjour Monde!'
  end
</pre>
<p>
Installez le gem et lancez avec:
</p>
<pre>
  gem install sinatra
  ruby -rubygems mon_application.rb
</pre>
<p>
Le résultat est visible sur: <a
href="http://localhost:4567">localhost:4567</a>
</p>
<p>
Il est également recommandé d&#8217;exécuter <tt>gem install thin</tt>,
que <a href="Sinatra.html">Sinatra</a> utilisera si disponible.
</p>
<h2>Routes</h2>
<p>
Dans <a href="Sinatra.html">Sinatra</a>, une route est une méthode HTTP
couplée à un masque (pattern) URL. Chaque route est associée à un bloc:
</p>
<pre>
  get '/' do
    .. montrer quelque chose ..
  end

  post '/' do
    .. créer quelque chose ..
  end

  put '/' do
    .. changer quelque chose ..
  end

  delete '/' do
    .. effacer quelque chose ..
  end

  options '/' do
    .. apaiser quelquechose ..
  end
</pre>
<p>
Les routes sont comparées dans l&#8217;ordre où elles ont été
définies. La première route qui correspond à la requête est invoquée.
</p>
<p>
Les masques peuvent inclure des paramètres nommés, accessibles par
l&#8217;intermédiaire du hash <tt>params</tt>:
</p>
<pre>
  get '/bonjour/:nom' do
    # répond aux requêtes &quot;GET /bonjour/foo&quot; et &quot;GET /bonjour/bar&quot;
    # params[:nom] est 'foo' ou 'bar'
    &quot;Bonjour #{params[:nom]}!&quot;
  end
</pre>
<p>
Vous pouvez aussi les nommer directement dans les paramètres du bloc comme
ceci:
</p>
<pre>
  get '/bonjour/:nom' do |n|
    &quot;Bonjour #{n}!&quot;
  end
</pre>
<p>
Une route peut contenir un splat (caractère joker), accessible par
l&#8217;intermédiaire de la liste <tt>params[:splat]</tt>:
</p>
<pre>
  get '/dire/*/a/*' do
    # répondrait à /dire/bonjour/a/monde
    params[:splat] # =&gt; [&quot;bonjour&quot;, &quot;monde&quot;]
  end

  get '/telecharger/*.*' do
    # répondrait à /telecharger/chemin/vers/fichier.xml
    params[:splat] # =&gt; [&quot;chemin/vers/fichier&quot;, &quot;xml&quot;]
  end
</pre>
<p>
Une route peut s&#8217;exprimer avec une Expression Régulière:
</p>
<pre>
  get %r{/bonjour/([\w]+)} do
    &quot;Bonjour, #{params[:captures].first}!&quot;
  end
</pre>
<p>
Là aussi on peut utiliser les paramètres de bloc:
</p>
<pre>
  get %r{/bonjour/([\w]+)} do |c|
    &quot;Bonjour, #{c}!&quot;
  end
</pre>
<h3>Conditions</h3>
<p>
Les routes peuvent définir toutes sortes de conditions, comme par exemple
le &#8220;user agent&#8221;:
</p>
<pre>
  get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
    &quot;Vous utilisez Songbird version #{params[:agent][0]}&quot;
  end

  get '/foo' do
    # Correspond à tous les autres navigateurs
  end
</pre>
<p>
Les autres conditions disponibles sont <tt>host_name</tt> et
<tt>provides</tt>:
</p>
<pre>
  get '/', :host_name =&gt; /^admin\./ do
    &quot;Zone Administrateur, Accès refusé!&quot;
  end

  get '/', :provides =&gt; 'html' do
    haml :index
  end

  get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
    builder :feed
  end
</pre>
<p>
Vous pouvez facilement définir vos propres conditions:
</p>
<pre>
  set(:probability) { |value| condition { rand &lt;= value } }

  get '/gagner_une_voiture', :probability =&gt; 0.1 do
    &quot;Vous avez gagné!&quot;
  end

  get '/gagner_une_voiture' do
    &quot;Désolé, vous avez perdu.&quot;
  end
</pre>
<h3>Valeurs de retour</h3>
<p>
La valeur de retour d&#8217;un bloc définissant une route détermine le
corps de la réponse qui sera transmise au client HTTP ou du moins au
prochain middleware dans la pile Rack. Le plus généralement, il
s&#8217;agit d&#8217;une chaîne de caractères, comme dans les exemples
précédents. Cependant, d&#8217;autres valeurs sont acceptées.
</p>
<p>
Vous pouvez renvoyer n&#8217;importe quel objet qui soit une réponse Rack
valide, un corps de réponse Rack ou un code retour HTTP:
</p>
<ul>
<li><p>
Un tableau de 3 éléments: <tt>[code retour (Fixnum), entêtes (Hash),
corps de réponse (répondant à each)]</tt>
</p>
</li>
<li><p>
Un tableau de 2 élements: <tt>[code retour (Fixnum), corps de réponse
(répondant à each)]</tt>
</p>
</li>
<li><p>
Un objet qui répond à <tt>each</tt> et qui ne transmet que des chaînes
de caractères au bloc fourni
</p>
</li>
<li><p>
Un Fixnum représentant le code retour
</p>
</li>
</ul>
<p>
Ainsi, on peut facilement implémenter un streaming par exemple :
</p>
<pre>
    class Stream
      def each
        100.times { |i| yield &quot;#{i}\n&quot; }
      end
    end

    get('/') { Stream.new }
</pre>
<h3>Masques de route spécifiques</h3>
<p>
Comme montré plus haut, <a href="Sinatra.html">Sinatra</a> embarque le
support pour l&#8217;utilisation de masques utilisant des chaînes de
caractères ou des expressions régulières pour définir les routes.
Toutefois, cela ne s&#8217;arrête pas là. Vous pouvez facilement définir
vos propres masques :
</p>
<pre>
  class MasqueToutSauf
    Masque = Struct.new(:captures)

    def initialize(except)
      @except   = except
      @captures = Masque.new([])
    end

    def match(str)
      @caputres unless @except === str
    end
  end

  def tout_sauf(masque)
    MasqueToutSauf.new(masque)
  end

  get tout_sauf(&quot;/index&quot;) do
    # ...
  end
</pre>
<p>
Notez que l&#8217;exemple ci-dessus est bien trop compliqué et le même
résultat peut être obtenu avec :
</p>
<pre>
  get // do
    pass if request.path_info == &quot;/index&quot;
    # ...
  end
</pre>
<p>
Ou bien en utilisant la forme négative :
</p>
<pre>
  get %r{^(?!/index$)} do
    # ...
  end
</pre>
<h2>Fichiers statiques</h2>
<p>
Par défaut, le dossier <tt>./public</tt> est utilisé pour servir les
fichiers statiques. Vous pouvez changer ce dossier pour un autre nom grâce
au paramètre <tt>:public</tt>:
</p>
<pre>
  set :public, File.dirname(__FILE__) + '/statique'
</pre>
<p>
Notez que le nom du dossier public n&#8217;est pas inclus dans l&#8217;URL.
Un fichier sous <tt>./public/css/style.css</tt> est appelé avec
l&#8217;URL : <tt><a
href="http://exemple.com/css/style.css">exemple.com/css/style.css</a></tt>.
</p>
<h2>Vues / Templates</h2>
<p>
Par défaut, les templates sont cherchés dans le dossier <tt>./views</tt>.
Pour utiliser un autre dossier, il faut le déclarer:
</p>
<pre>
  set :views, File.dirname(__FILE__) + '/templates'
</pre>
<p>
Il est important de noter que les templates sont toujours référencés
sous forme de symboles, même s&#8217;il s&#8217;agit d&#8217;un
sous-répertoire (dans ce cas, utilisez
<tt>:'sous_repertoire/template'</tt>). Vous devez utiliser un symbole car
les méthodes de rendu évalueront le contenu des chaînes de caractères
au lieu de les considérer comme un chemin vers un fichier.
</p>
<h3>Templates Haml</h3>
<p>
Le gem <tt>haml</tt> est nécessaire pour utiliser la fonction de rendu
Haml:
</p>
<pre>
  # Chargez la bibliothèque haml dans votre application
  require 'haml'

  get '/' do
    haml :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.haml</tt>.
</p>
<p>
<a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Les
options de Haml</a> peuvent se manipuler directement avec la configuration
de <a href="Sinatra.html">Sinatra</a>, voir <a
href="http://www.sinatrarb.com/configuration.html">Options et
Configuration</a>, et supportent aussi la réécriture (surcharge) comme
dans cet exemple.
</p>
<pre>
  set :haml, :format =&gt; :html5 # le format par défaut dans Haml est :xhtml

  get '/' do
    haml :index, :format =&gt; :html4 # surcharge
  end
</pre>
<h3>Templates Erb</h3>
<pre>
  # Chargez la bibliothèque erb dans votre application
  require 'erb'

  get '/' do
    erb :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.erb</tt>.
</p>
<h3>Templates Erubis</h3>
<p>
Le gem <tt>erubis</tt> est nécessaire pour utiliser la fonction de rendu
erubis:
</p>
<pre>
  # Chargez la bibliothèque erubis dans votre application
  require 'erubis'

  get '/' do
    erubis :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.erubis</tt>
</p>
<p>
Il est également possible de remplacer Erb par Erubis:
</p>
<pre>
  require 'erubis'
  Tilt.register :erb, Tilt[:erubis]

  get '/' do
    erb :index
  end
</pre>
<p>
Utilisera le template <tt>./views/index.erb</tt> avec Erubis.
</p>
<h3>Templates Builder</h3>
<p>
Le gem <tt>builder</tt> est nécessaire pour utiliser la fonction de rendu
builder:
</p>
<pre>
  # Chargez la bibliothèque builder dans votre application
  require 'builder'

  get '/' do
    builder :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.builder</tt>.
</p>
<h3>Templates Nokogiri</h3>
<p>
Le gem <tt>nokogiri</tt> est nécessaire pour utiliser la fonction de rendu
nokogiri:
</p>
<pre>
  # Chargez la bibliothèque nokogiri dans votre application
  require 'nokogiri'

  get '/' do
    nokogiri :index
  end
</pre>
<p>
Utilisera le template: <tt>./views/index.nokogiri</tt>.
</p>
<h3>Templates Sass</h3>
<p>
Le gem <tt>haml</tt> ou <tt>sass</tt> est nécessaire pour utiliser la
fonction de rendu Sass:
</p>
<pre>
  # Chargez la bibliothèque haml ou sass dans votre application
  require 'sass'

  get '/stylesheet.css' do
    sass :stylesheet
  end
</pre>
<p>
Utilisera le template: <tt>./views/stylesheet.sass</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Les
options de Sass</a> peuvent se manipuler directement avec la configuration
de <a href="Sinatra.html">Sinatra</a>, voir <a
href="http://www.sinatrarb.com/configuration.html">Options et
Configuration</a>, et supportent aussi la réécriture (surcharge) comme
dans cet exemple.
</p>
<pre>
  set :sass, :style =&gt; :compact # le style par défaut dans Sass est :nested

  get '/stylesheet.css' do
    sass :stylesheet, :style =&gt; :expanded # surcharge
  end
</pre>
<h3>Scss Templates</h3>
<p>
Le gem <tt>haml</tt> ou <tt>sass</tt> est nécessaire pour utiliser la
fonction de rendu Scss:
</p>
<pre>
  # Chargez la bibliothèque haml ou sass dans votre application
  require 'sass'

  get '/stylesheet.css' do
    scss :stylesheet
  end
</pre>
<p>
Utilisera le template <tt>./views/stylesheet.scss</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Les
options de Scss</a> peuvent se manipuler directement avec la configuration
de <a href="Sinatra.html">Sinatra</a>, voir <a
href="http://www.sinatrarb.com/configuration.html">Options et
Configuration</a>, et supportent aussi la réécriture (surcharge) comme
dans cet exemple.
</p>
<pre>
  set :scss, :style =&gt; :compact # le style par défaut de Scss est :nested

  get '/stylesheet.css' do
    scss :stylesheet, :style =&gt; :expanded # surcharge
  end
</pre>
<h3>Templates Less</h3>
<p>
Le gem <tt>less</tt> est nécessaire pour utiliser la fonction de rendu
Less:
</p>
<pre>
  # Chargez la bibliothèque less dans votre application
  require 'less'

  get '/stylesheet.css' do
    less :stylesheet
  end
</pre>
<p>
Utilisera le template: <tt>./views/stylesheet.less</tt>.
</p>
<h3>Templates Liquid</h3>
<p>
Le gem <tt>liquid</tt> est nécessaire pour utiliser la fonction de rendu
Liquid:
</p>
<pre>
  # Chargez la bibliothèque liquid dans votre application
  require 'liquid'

  get '/' do
    liquid :index
  end
</pre>
<p>
Utilisera <tt>./views/index.liquid</tt>.
</p>
<p>
Comme vous ne pouvez pas appeler des méthodes Ruby (excepté
<tt>yield</tt>) dans un template Liquid, il sera toujours nécessaire de
lui passer des variables locales:
</p>
<pre>
  liquid :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<h3>Templates Markdown</h3>
<p>
Le gem <tt>rdiscount</tt> est nécessaire pour utiliser la fonction de
rendu Markdown:
</p>
<pre>
  # Chargez la bibliothèque rdiscount dans votre application
  require &quot;rdiscount&quot;

  get '/' do
    markdown :index
  end
</pre>
<p>
Utilisera <tt>./views/index.markdown</tt> (les extensions de fichier
<tt>md</tt> et <tt>mkd</tt> sont également acceptées).
</p>
<p>
Il n&#8217;est pas possible d&#8217;appeler des méthodes depuis markdown,
ni même de lui passer des variables locales. Par conséquent, il sera le
plus souvent utilisé en combinaison avec un autre moteur de rendu:
</p>
<pre>
  erb :vuedensemble, :locals =&gt; { :texte =&gt; markdown(:introduction) }
</pre>
<p>
Notez que vous pouvez également appeler la méthode <tt>markdown</tt> au
sein d&#8217;autres templates:
</p>
<pre>
  %h1 Bonjour Depuis Haml!
  %p= markdown(:salutations)
</pre>
<p>
Comme vous ne pouvez pas faire d&#8217;appels Ruby au sein de Markdown,
vous ne pouvez pas utiliser des layouts écrits en Markdown. Il est
toutefois possible d&#8217;utiliser un autre moteur de rendu pour le layout
en passant l&#8217;option <tt>:layout_engine</tt> :
</p>
<pre>
  get '/' do
    markdown :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.md</tt> avec <tt>./views/layout.erb</tt>
pour layout.
</p>
<p>
Souvenez vous que vous pouvez spécifier de telles options de rendu
globalement :
</p>
<pre>
  set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    markdown :index
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.md</tt> (et tout autre template Markdown)
avec <tt>./views/post.haml</tt> pour layout.
</p>
<p>
Il est également possible de traduire le Markdown avec BlueCloth plutôt
que RDiscount :
</p>
<pre>
  require 'bluecloth'

  Tilt.register 'markdown', BlueClothTemplate
  Tilt.register 'mkd',      BlueClothTemplate
  Tilt.register 'md',       BlueClothTemplate

  get '/' do
    markdown :index
  end
</pre>
<p>
Utilisera <tt>./views/index.md</tt> avec BlueCloth.
</p>
<h3>Templates Textile</h3>
<p>
Le gem <tt>RedCloth</tt> est nécessaire pour utiliser la fonction de rendu
Textile:
</p>
<pre>
  # Chargez la bibliothèqye redcloth dans votre application
  require &quot;redcloth&quot;

  get '/' do
    textile :index
  end
</pre>
<p>
Utilisera <tt>./views/index.textile</tt>.
</p>
<p>
Il n&#8217;est pas possible d&#8217;appeler des méthodes depuis textile,
ni même de lui passer des variables locales. Par conséquent, il sera le
plus souvent utilisé en combinaison avec un autre moteur de rendu:
</p>
<pre>
  erb :vuedensemble, :locals =&gt; { :texte =&gt; textile(:introduction) }
</pre>
<p>
Notez que vous pouvez également appeler la méthode <tt>textile</tt> au
sein d&#8217;autres templates:
</p>
<pre>
  %h1 Bonjour Depuis Haml!
  %p= textile(:salutations)
</pre>
<p>
Comme vous ne pouvez pas faire d&#8217;appels Ruby au sein de Textile, vous
ne pouvez pas utiliser des layouts écrits en Textile. Il est toutefois
possible d&#8217;utiliser un autre moteur de rendu pour le layout en
passant l&#8217;option <tt>:layout_engine</tt> :
</p>
<pre>
  get '/' do
    textile :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.textile</tt> avec
<tt>./views/layout.erb</tt> pour layout.
</p>
<p>
Souvenez vous que vous pouvez spécifier de telles options de rendu
globalement :
</p>
<pre>
  set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    textile :index
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.textile</tt> (et tout autre template
Textile) avec <tt>./views/post.haml</tt> pour layout.
</p>
<h3>Templates RDoc</h3>
<p>
Le gem <tt>rdoc</tt> est nécessaire pour utiliser la fonction de rendu
RDoc:
</p>
<pre>
  # Chargez la bibliothèque rdoc/markup/to_html dans votre application
  require &quot;rdoc/markup/to_html&quot;

  get '/' do
    rdoc :index
  end
</pre>
<p>
Utilisera <tt>./views/index.rdoc</tt>.
</p>
<p>
Il n&#8217;est pas possible d&#8217;appeler des méthodes depuis rdoc, ni
même de lui passer des variables locales. Par conséquent, il sera le plus
souvent utilisé en combinaison avec un autre moteur de rendu:
</p>
<pre>
  erb :vuedensemble, :locals =&gt; { :texte =&gt; rdoc(:introduction) }
</pre>
<p>
Notez que vous pouvez également appeler la méthode <tt>rdoc</tt> au sein
d&#8217;autres templates:
</p>
<pre>
  %h1 Bonjour Depuis Haml!
  %p= rdoc(:salutations)
</pre>
<p>
Comme vous ne pouvez pas faire d&#8217;appels Ruby au sein de RDoc, vous ne
pouvez pas utiliser des layouts écrits en RDoc. Il est toutefois possible
d&#8217;utiliser un autre moteur de rendu pour le layout en passant
l&#8217;option <tt>:layout_engine</tt> :
</p>
<pre>
  get '/' do
    rdoc :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.rdoc</tt> avec <tt>./views/layout.erb</tt>
pour layout.
</p>
<p>
Souvenez vous que vous pouvez spécifier de telles options de rendu
globalement :
</p>
<pre>
  set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    rdoc :index
  end
</pre>
<p>
Ceci utilisera <tt>./views/index.rdoc</tt> (et tout autre template RDoc)
avec <tt>./views/post.haml</tt> pour layout.
</p>
<h3>Templates Radius</h3>
<p>
Le gem radius est nécessaire pour utiliser la fonction de rendu Radius:
</p>
<pre>
  # Chargez la bibliothèque radius dans votre application
  require 'radius'

  get '/' do
    radius :index
  end
</pre>
<p>
Utilisera <tt>./views/index.radius</tt>.
</p>
<p>
Comme vous ne pouvez pas appeler des méthodes Ruby (excepté
<tt>yield</tt>) dans un template Radius, il sera toujours nécessaire de
lui passer des variables locales:
</p>
<pre>
  radius :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<h3>Templates Markaby</h3>
<p>
Le gem markaby est nécessaire pour utiliser la fonction de rendu Markaby:
</p>
<pre>
  # Chargez la bibliothèque markaby dans votre application
  require 'markaby'

  get '/' do
    markaby :index
  end
</pre>
<p>
Utilisera <tt>./views/index.mab</tt>.
</p>
<p>
Vous pouvez également utiliser Markaby en ligne :
</p>
<pre>
  get '/' do
    markaby { h1 &quot;Salut !&quot; }
  end
</pre>
<h3>Templates Slim</h3>
<p>
Le gem slim est nécessaire pour utiliser la fonction de rendu Slim:
</p>
<pre>
  # Chargez la bibliothèque slim dans votre application
  require 'slim'

  get '/' do
    slim :index
  end
</pre>
<p>
Utilisera <tt>./views/index.slim</tt>.
</p>
<h3>Templates CoffeeScript</h3>
<p>
Le gem <tt>coffee-script</tt> est nécessaire ainsi que l&#8217;<b>une</b>
des options suivantes permettant l&#8217;exécution de Java script :
</p>
<ul>
<li><p>
<tt>node</tt> (de Node.js) dans votre path
</p>
</li>
<li><p>
vous êtes sous OSX
</p>
</li>
<li><p>
le gem <tt>therubyracer</tt>
</p>
</li>
</ul>
<p>
Voir <a
href="http://github.com/josh/ruby-coffee-script">github.com/josh/ruby-coffee-script</a>
pour une liste à jour d&#8217;options possibles.
</p>
<p>
Maintenant vous pouvez générer des templates CoffeeScript :
</p>
<pre>
  # Chargez la bibliothèque coffee-script dans votre application
  require 'coffee-script'

  get '/application.js' do
    coffee :application
  end
</pre>
<p>
Utilisera <tt>./views/application.coffee</tt>.
</p>
<h3>Templates embarqués</h3>
<pre>
  get '/' do
    haml '%div.title Bonjour Monde'
  end
</pre>
<p>
Générera le template embarqué spécifié dans la chaîne de caractères.
</p>
<h3>Accéder aux variables dans un Template</h3>
<p>
Un template est évalué dans le même contexte que l&#8217;endroit
d&#8217;où il a été appelé (gestionnaire de route). Les variables
d&#8217;instance déclarées dans le gestionnaire de route sont directement
accessibles dans le template:
</p>
<pre>
  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.nom'
  end
</pre>
<p>
Alternativement, on peut passer un hash contenant des variables locales:
</p>
<pre>
  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.nom', :locals =&gt; { :foo =&gt; foo }
  end
</pre>
<p>
Ceci est généralement utilisé lorsque l&#8217;on veut utiliser un
template comme partiel (depuis un autre template) et qu&#8217;il est donc
nécessaire d&#8217;adapter les noms de variables.
</p>
<h3>Templates dans le fichier source</h3>
<p>
Des templates peuvent être définis dans le fichier source comme ceci:
</p>
<pre>
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Bonjour Monde!!!!!
</pre>
<p>
NOTE: Les templates du fichier source qui contient <tt>require
'sinatra'</tt> sont automatiquement chargés. Si vous avez des templates
dans d&#8217;autres fichiers source, il faut explicitement les déclarer
via: <tt>enable :inline_templates</tt>.
</p>
<h3>Templates nommés</h3>
<p>
Les templates peuvent aussi être définis grâce à la méthode de haut
niveau <tt>template</tt>:
</p>
<pre>
  template :layout do
    &quot;%html\n  =yield\n&quot;
  end

  template :index do
    '%div.title Bonjour Monde!'
  end

  get '/' do
    haml :index
  end
</pre>
<p>
Si un template nommé &#8220;layout&#8221; existe, il sera utilisé à
chaque fois qu&#8217;un template sera affiché. Vous pouvez désactivez les
layouts au cas par cas en passant <tt>:layout =&gt; false</tt> ou bien les
désactiver par défaut au moyen de <tt>set :haml, :layout =&gt;
false</tt>:
</p>
<pre>
  get '/' do
    haml :index, :layout =&gt; !request.xhr?
  end
</pre>
<h3>Associer des extensions de fichier</h3>
<p>
Pour associer une extension de fichier avec un moteur de rendu, utilisez
<tt>Tilt.register</tt>. Par exemple, si vous désirez utiliser
l&#8217;extension de fichier <tt>tt</tt> pour les templates Textile, vous
pouvez faire comme suit :
</p>
<pre>
  Tilt.register :tt, Tilt[:textile]
</pre>
<h3>Ajouter son propre moteur de rendu</h3>
<p>
En premier lieu, déclarez votre moteur de rendu avec Tilt, ensuite créez
votre méthode de rendu :
</p>
<pre>
  Tilt.register :monmoteur, MonMerveilleurMoteurDeRendu

  helpers do
    def monmoteur(*args) render(:monmoteur, *args) end
  end

  get '/' do
    monmoteur :index
  end
</pre>
<p>
Utilisera <tt>./views/index.monmoteur</tt>. Voir <a
href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a> pour
en savoir plus sur Tilt.
</p>
<h2>Filtres</h2>
<p>
Un filtre <tt>before</tt> est évalué avant n&#8217;importe quelle
requête, dans le contexte de celle-ci, et peut modifier la requête ou la
réponse. Les variables d&#8217;instance déclarées dans le filtre sont
accessibles au gestionnaire de route et au template:
</p>
<pre>
  before do
    @note = 'Coucou!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=&gt; 'Coucou!'
    params[:splat] #=&gt; 'bar/baz'
  end
</pre>
<p>
Un filtre <tt>after</tt> est évalué après chaque requête, dans le
contexte de celle-ci et peut également modifier la requête et/ou la
réponse. Toutes les variables d&#8217;instance déclarées dans un filtre
<tt>before</tt> et dans le gestionnaire de route sont accessibles dans le
filtre <tt>after</tt>:
</p>
<pre>
  after do
    puts response.status
  end
</pre>
<p>
Note : Sauf si vous utilisez la méthode <tt>body</tt> au lieu de renvoyer
une chaîne de caractères dans vos gestionnaires de routes, le corps de la
réponse ne sera pas disponible dans le filtre <tt>after</tt>, étant
donné qu&#8217;il est généré plus tard.
</p>
<p>
En option, on peut passer un masque au filtre, ce qui le rend actif
uniquement si la requête correspond au masque en question:
</p>
<pre>
  before '/secret/*' do
    authentification!
  end

  after '/faire/:travail' do |travail|
    session[:dernier_travail] = travail
  end
</pre>
<p>
Tout comme les routes, les filtres acceptent également les conditions :
</p>
<pre>
  before :agent =&gt; /Songbird/ do
    # ...
  end

  after '/blog/*', :host_name =&gt; 'example.com' do
    # ...
  end
</pre>
<h2>Helpers</h2>
<p>
Utilisez la méthode de haut niveau <tt>helpers</tt> pour définir des
routines qui seront accessibles dans vos gestionnaires de route et dans vos
templates :
</p>
<pre>
  helpers do
    def bar(nom)
      &quot;#{nom}bar&quot;
    end
  end

  get '/:nom' do
    bar(params[:nom])
  end
</pre>
<h3>Utiliser les sessions</h3>
<p>
Une session est utilisé pour conserver un état entre les requêtes. Une
fois activées, vous avez un <tt>hash</tt> de session par session
utilisateur :
</p>
<pre>
  enable :sessions

  get '/' do
    &quot;valeur = &quot; &lt;&lt; session[:valeur].inspect
  end

  get '/:value' do
    session[:valeur] = params[:valeur]
  end
</pre>
<p>
Notez que <tt>enable :sessions</tt> enregistre en fait toutes les données
dans un <tt>cookie</tt>. Ce n&#8217;est pas toujours ce que vous voulez
(enregistrer beaucoup de données va augmenter le traffic par exemple).
Vous pouvez utiliser n&#8217;importe quel <tt>middleware</tt> Rack de
session afin d&#8217;éviter cela. N&#8217;utiliser <b>pas</b> <tt>enable
:sessions</tt> dans ce cas mais charger le <tt>middleware</tt> de votre
choix comme vous le feriez pour n&#8217;importe quel autre
<tt>middleware</tt> :
</p>
<pre>
  use Rack::Session::Pool, :expire_after =&gt; 2592000

  get '/' do
    &quot;valeur = &quot; &lt;&lt; session[:valeur].inspect
  end

  get '/:value' do
    session[:valeur] = params[:valeur]
  end
</pre>
<h2>Halt</h2>
<p>
Pour arrêter immédiatement la requête dans un filtre ou un gestionnaire
de route:
</p>
<pre>
  halt
</pre>
<p>
Vous pouvez aussi passer le code retour &#8230;
</p>
<pre>
  halt 410
</pre>
<p>
Ou le texte &#8230;
</p>
<pre>
  halt 'Ceci est le texte'
</pre>
<p>
Ou les deux &#8230;
</p>
<pre>
  halt 401, 'Partez!'
</pre>
<p>
Ainsi que les entêtes &#8230;
</p>
<pre>
  halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revanche'
</pre>
<p>
Bien sûr il est possible de cominer un template avec <tt>halt</tt>:
</p>
<pre>
  halt erb(:erreur)
</pre>
<h2>Passer</h2>
<p>
Une route peut passer le relais aux autres routes qui correspondent
également avec <tt>pass</tt>:
</p>
<pre>
  get '/devine/:qui' do
    pass unless params[:qui] == 'Frank'
    &quot;Tu m'as eu!&quot;
  end

  get '/devine/*' do
    'Manqué!'
  end
</pre>
<p>
On sort donc immédiatement de ce gestionnaire et on continue à chercher,
dans les masques suivants, le prochain qui correspond à la requête. Si
aucun des masques suivants ne correspond, un code 404 est retourné.
</p>
<h3>Déclencher une autre route</h3>
<p>
Parfois, <tt>pass</tt> n&#8217;est pas ce que vous recherchez, au lieu de
cela vous souhaitez obtenir le résultat d&#8217;une autre route. Pour
cela, utilisez simplement <tt>call</tt> :
</p>
<pre>
  get '/foo' do
    status, headers, body = call env.merge(&quot;PATH_INFO&quot; =&gt; '/bar')
    [status, headers, body.map(&amp;:upcase)]
  end

  get '/bar' do
    &quot;bar&quot;
  end
</pre>
<p>
Notez que dans l&#8217;exemple ci-dessus, vous faciliterez les tests et
améliorerez la performance en déplaçant simplement
<tt>&quot;bar&quot;</tt> dans un <tt>helper</tt> utilisé à la fois par
<tt>/foo</tt> et <tt>/bar</tt>.
</p>
<p>
Si vous souhiatez que la requête soit envoyée à la même instance de
l&#8217;application plutôt qu&#8217;à une copie, utilisez <tt>call!</tt>
au lieu de <tt>call</tt>.
</p>
<p>
Lisez la spécification Rack si vous souhaitez en savoir plus sur
<tt>call</tt>.
</p>
<h3>Définir le corps, le code retour et les entêtes</h3>
<p>
Il est possible et recommandé de définir le code retour et le corps de la
réponse au moyen de la valeur de retour d&#8217;un bloc définissant une
route. Quoiqu&#8217;il en soit, dans certains cas vous pourriez avoir
besoin de définir le coprs de la réponse à un moment arbitraire de
l&#8217;exécution. Vous pouvez le faire au moyen de la méthode
<tt>body</tt>. Si vous faites ainsi, vous pouvez alors utiliser cette même
méthode pour accéder au corps de la réponse :
</p>
<pre>
  get '/foo' do
    body &quot;bar&quot;
  end

  after do
    puts body
  end
</pre>
<p>
Il est également possible de passer un bloc à <tt>body</tt>, qui sera
exécuté par le gestionnaire Rack (ceci peut être utilisé pour
implémenter un <tt>streaming</tt>, voir &#8220;Valeurs de retour&#8221;).
</p>
<p>
Pareillement au corps de la réponse, vous pouvez également définir le
code retour et les entêtes :
</p>
<pre>
  get '/foo' do
    status 418
    headers \
      &quot;Allow&quot;   =&gt; &quot;BREW, POST, GET, PROPFIND, WHEN&quot;
      &quot;Refresh&quot; =&gt; &quot;Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt&quot;
    body &quot;I'm a tea pot!&quot;
  end
</pre>
<p>
Comme <tt>body</tt>, <tt>headers</tt> et <tt>status</tt> peuvent être
utilisés sans arguments pour accéder à leurs valeurs.
</p>
<h3>Types Mime</h3>
<p>
Quand vous utilisez <tt>send_file</tt> ou des fichiers statiques, vous
pouvez rencontrer des types mime que <a href="Sinatra.html">Sinatra</a> ne
connaît pas. Utilisez <tt>mime_type</tt> pour les déclarer par extension
de fichier :
</p>
<pre>
  mime_type :foo, 'text/foo'
</pre>
<p>
Vous pouvez également les utiliser avec la méthode <tt>content_type</tt>
:
</p>
<pre>
  get '/' do
    content_type :foo
    &quot;foo foo foo&quot;
  end
</pre>
<h3>Former des URLs</h3>
<p>
Pour former des URLs, vous devriez utiliser la méthode <tt>url</tt>, par
exemple en Haml :
</p>
<pre>
  %a{:href =&gt; url('/foo')} foo
</pre>
<p>
Cela prend en compte les proxy inverse et les routeurs Rack, s&#8217;ils
existent.
</p>
<p>
Cette méthode est également disponible sous l&#8217;alias <tt>to</tt>
(voir ci-dessous pour un exemple).
</p>
<h3>Redirection du navigateur</h3>
<p>
Vous pouvez déclencher une redirection du navigateur avec la méthode
<tt>redirect</tt> :
</p>
<pre>
  get '/foo' do
    redirect to('/bar')
  end
</pre>
<p>
Tout paramètre additionnel est géré comme des arguments pour la méthode
<tt>halt</tt> :
</p>
<pre>
  redirect to('/bar'), 303
  redirect 'http://google.com', 'mauvais endroit mon pote'
</pre>
<p>
Vous pouvez aussi rediriger vers la page dont l&#8217;utilisateur venait au
moyen de <tt>redirect back</tt>:
</p>
<pre>
  get '/foo' do
    &quot;&lt;a href='/bar'&gt;faire quelque chose&lt;/a&gt;&quot;
  end

  get '/bar' do
    faire_quelque_chose
    redirect back
  end
</pre>
<p>
Pour passer des arguments à une redirection, ajoutez-les soit à la
requête :
</p>
<pre>
  redirect to('/bar?sum=42')
</pre>
<p>
Ou bien utilisez une session :
</p>
<pre>
  enable :session

  get '/foo' do
    session[:secret] = 'foo'
    redirect to('/bar')
  end

  get '/bar' do
    session[:secret]
  end
</pre>
<h3>Contrôle du cache</h3>
<p>
Définir correctement vos entêtes à la base pour un bon cahce HTTP.
</p>
<p>
Vous pouvez facilement définir l&#8217;entête Cache-Control de la
manière suivante :
</p>
<pre>
  get '/' do
    cache_control :public
    &quot;met le en cache !&quot;
  end
</pre>
<p>
Conseil de pro : définir le cache dans un filtre <tt>before</tt>:
</p>
<pre>
  before do
    cache_control :public, :must_revalidate, :max_age =&gt; 60
  end
</pre>
<p>
Si vous utilisez la méthode <tt>expires</tt> pour définir l&#8217;entête
correspondant, <tt>Cache-Control</tt> sera alors défini automatiquement :
</p>
<pre>
  before do
    expires 500, :public, :must_revalidate
  end
</pre>
<p>
Pour utiliser correctement les caches, vous devriez utiliser <tt>etag</tt>
et <tt>last_modified</tt>. Il est recommandé d&#8217;utiliser ces
méthodes <b>avant</b> de faire d&#8217;important modifications, car elles
vont immédiatement déclencher la réponse si le client a déjà la
version courante dans son cache:
</p>
<pre>
  get '/article/:id' do
    @article = Article.find params[:id]
    last_modified @article.updated_at
    etag @article.sha1
    erb :article
  end
</pre>
<p>
Il est également possible d&#8217;utiliser un <a
href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak
ETag</a>:
</p>
<pre>
  etag @article.sha1, :weak
</pre>
<p>
Ces méthodes ne sont pas chargées de mettre des données en cache, mais
elles fournissent les informations nécessaires pour votre cache. Si vous
êtes à la recherche de solutions rapides de cache, essayez <a
href="http://rtomayko.github.com/rack-cache/">rack-cache</a>:
</p>
<pre>
  require &quot;rack/cache&quot;
  require &quot;sinatra&quot;

  use Rack::Cache

  get '/' do
    cache_control :public, :max_age =&gt; 36000
    sleep 5
    &quot;hello&quot;
  end
</pre>
<h3>Envoyer des fichiers</h3>
<p>
Pour envoyer des fichiers, vous pouvez utiliser la méthode
<tt>send_file</tt> :
</p>
<pre>
  get '/' do
    send_file 'foo.png'
  end
</pre>
<p>
Quelques options sont également acceptées :
</p>
<pre>
  send_file 'foo.png', :type =&gt; :jpg
</pre>
<p>
Les options sont :
</p>
<dl>
<dt>filename</dt><dd><p>
le nom du fichier dans la réponse, par défaut le nom du fichier envoyé.
</p>
</dd>
<dt>last_modified</dt><dd><p>
valeur pour l&#8217;entête Last-Modified, par défaut la date de
modification du fichier
</p>
</dd>
<dt>type</dt><dd><p>
type de contenu à utiliser, deviné à partir de l&#8217;extension de
fichier si absent
</p>
</dd>
<dt>disposition</dt><dd><p>
utilisé pour Content-Disposition, les valuers possibles étant :
<tt>nil</tt> (par défaut), <tt>:attachment</tt> et <tt>:inline</tt>
</p>
</dd>
<dt>length</dt><dd><p>
entête Content-Length, par défaut la taille du fichier
</p>
</dd>
</dl>
<p>
Si le gestionnaire Rack le supporte, d&#8217;autres moyens que le
<tt>streaming</tt> via le processus Ruby seront utilisés. Si vous utilisez
cette méthode, <a href="Sinatra.html">Sinatra</a> gérera automatiquement
les requêtes de type <tt>range</tt>.
</p>
<h2>Accéder à l&#8217;objet requête</h2>
<p>
L&#8217;objet correspondant à la requête envoyée peut être récupéré
dans le contexte de la requête (filtres, routes, gestionnaires
d&#8217;erreur) au moyen de la méthode `request`:
</p>
<pre>
  # application tournant à l'adresse http://exemple.com/exemple
  get '/foo' do
    request.body              # corps de la requête envoyée par le client
                              # (voir ci-dessous)
    request.scheme            # &quot;http&quot;
    request.script_name       # &quot;/exemple&quot;
    request.path_info         # &quot;/foo&quot;
    request.port              # 80
    request.request_method    # &quot;GET&quot;
    request.query_string      # &quot;&quot;
    request.content_length    # taille de request.body
    request.media_type        # type de média pour request.body
    request.host              # &quot;exemple.com&quot;
    request.get?              # true (méthodes similaires pour les autres
                              # verbes HTTP)
    request.form_data?        # false
    request[&quot;UN_ENTETE&quot;]      # valeur de l'entête UN_ENTETE
    request.referer           # référant du client ou '/'
    request.user_agent        # user agent (utilisé par la condition :agent)
    request.cookies           # tableau contenant les cookies du navigateur
    request.xhr?              # requête AJAX ?
    request.url               # &quot;http://exemple.com/exemple/foo&quot;
    request.path              # &quot;/exemple/foo&quot;
    request.ip                # adresse IP du client
    request.secure?           # false
    request.forwarded?        # vrai (si on est derrière un proxy inverse)
    request.env               # tableau brut de l'environnement fourni par
                              # Rack
  end
</pre>
<p>
Certaines options, telles que <tt>script_name</tt> ou <tt>path_info</tt>
peuvent également être modifiées:
</p>
<pre>
  before { request.path_info = &quot;/&quot; }

  get &quot;/&quot; do
    &quot;toutes les requêtes arrivent ici&quot;
  end
</pre>
<p>
<tt>request.body</tt> est un objet IO ou StringIO:
</p>
<pre>
  post &quot;/api&quot; do
    request.body.rewind  # au cas où il a déjà été lu
    donnees = JSON.parse request.body.read
    &quot;Bonjour #{donnees['nom']}!&quot;
  end
</pre>
<h3>Fichiers joints</h3>
<p>
Vous pouvez utiliser la méthode <tt>attachment</tt> pour indiquer au
navigateur que la réponse devrait être stockée sur le disque plutôt
qu&#8217;affichée:
</p>
<pre>
  get '/' do
    attachment
    &quot;enregistre-le !&quot;
  end
</pre>
<p>
Vous pouvez également lui passer un nom de fichier :
</p>
<pre>
  get '/' do
    attachment &quot;info.txt&quot;
    &quot;enregistre-le !&quot;
  end
</pre>
<h3>Chercher les fichiers de templates</h3>
<p>
La méthode <tt>find_template</tt> est utilisée pour trouver les fichiers
de templates à générer :
</p>
<pre>
  find_template settings.views, 'foo', Tilt[:haml] do |file|
    puts &quot;pourrait être #{file}&quot;
  end
</pre>
<p>
Ce n&#8217;est pas très utilise. En revanche, il est utile de pouvoir
surcharger cette méthode afin de définir son propre mécanisme de
recherche. Par exemple, vous pouvez utiliser plus d&#8217;un répertoire de
vues :
</p>
<pre>
  set :views, ['views', 'templates']

  helpers do
    def find_template(views, name, engine, &amp;block)
      Array(views).each { |v| super(v, name, engine, &amp;block) }
    end
  end
</pre>
<p>
Un autre exemple est d&#8217;utiliser des répertoires différents pour des
moteurs de rendu différents :
</p>
<pre>
  set :views, :sass =&gt; 'views/sass', :haml =&gt; 'templates', :default =&gt; 'views'

  helpers do
    def find_template(views, name, engine, &amp;block)
      _, folder = views.detect { |k,v| engine == Tilt[k] }
      folder ||= views[:default]
      super(folder, name, engine, &amp;block)
    end
  end
</pre>
<p>
Vous pouvez également écrire cela dans une extension et la partager avec
d&#8217;autres !
</p>
<p>
Notez que <tt>find_template</tt> ne vérifie pas que le fichier existe mais
va plutôt exécuter le bloc pour tous les chemins possibles. Cela
n&#8217;induit pas un problème de performance dans le sens où
<tt>render</tt> va utiliser <tt>break</tt> dès qu&#8217;un fichier est
trouvé. De plus, l&#8217;emplacement des templates (et leur contenu) est
mis en cache si vous n&#8217;êtes pas en mode développement. Vous devriez
garder cela en tête si vous écrivez une méthode vraiment dingue.
</p>
<h2>Configuration</h2>
<p>
Lancé une seule fois au démarrage de tous les environnements:
</p>
<pre>
  configure do
    # définir un paramètre
    set :option, 'value'

    # définir plusieurs paramètre
    set :a =&gt; 1, :b =&gt; 2

    # identique à `set :option, true`
    enable :option

    # identique à `set :option, false`
    disable :option

    # vous pouvez également avoir des paramètres dynamiques avec des blocs
    set(:css_dir) { File.join(views, 'css') }
  end
</pre>
<p>
Lancé si l&#8217;environnement (variable d&#8217;environnement RACK_ENV)
est défini comme <tt>:production</tt>:
</p>
<pre>
  configure :production do
    ...
  end
</pre>
<p>
Lancé si l&#8217;environnement est <tt>:production</tt> ou <tt>:test</tt>:
</p>
<pre>
  configure :production, :test do
    ...
  end
</pre>
<p>
Vous pouvez accéder à ces paramètres via <tt>settings</tt> :
</p>
<pre>
  configure do
    set :foo, 'bar'
  end

  get '/' do
    settings.foo? # =&gt; true
    settings.foo  # =&gt; 'bar'
    ...
  end
</pre>
<h3>Paramètres disponibles</h3>
<dl>
<dt>absolute_redirects</dt><dd><p>
Si désactivé, <a href="Sinatra.html">Sinatra</a> permettra les
redirections relatives. Toutefois, <a href="Sinatra.html">Sinatra</a> ne
sera plus conforme à la RFC 2616 (HTTP 1.1), qui n&#8217;autorise que les
redirections absolues.
</p>
<p>
Activez si votre application tourne derrière un proxy inverse qui
n&#8217;a pas été correctement configuré. Notez que la méthode
<tt>url</tt> continuera de produire des URLs absolues, sauf si vous lui
passez <tt>false</tt> comme second argument.
</p>
<p>
Désactivé par défaut.
</p>
</dd>
<dt>add_charsets</dt><dd><p>
types mime pour lesquels la méthode <tt>content_type</tt> va
automatiquement ajouter l&#8217;information du <tt>charset</tt>.
</p>
<p>
Vous devriez lui ajouter des valeurs plutôt que de l&#8217;écraser :
</p>
<pre>
  settings.add_charsets &lt;&lt; &quot;application/foobar&quot;
</pre>
</dd>
<dt>app_file</dt><dd><p>
fichier de l&#8217;application principale, utilisé pour détecterla racine
du projet, le dossier public et le dossier de vues ainsi que pour les
templates en ligne.
</p>
</dd>
<dt>bind</dt><dd><p>
adresse IP sur laquelle se brancher (par défaut: 0.0.0.0). Utiliser
seulement pour le serveur intégré.
</p>
</dd>
<dt>default_encoding</dt><dd><p>
encodage à utiliser si inconnu (par défaut <tt>&quot;utf-8&quot;</tt>).
</p>
</dd>
<dt>dump_errors</dt><dd><p>
afficher les erreurs dans le <tt>log</tt>.
</p>
</dd>
<dt>environment</dt><dd><p>
environnement courant, par défaut <tt>ENV['RACK_ENV']</tt>, ou
<tt>&quot;development&quot;</tt> si absent.
</p>
</dd>
<dt>logging</dt><dd><p>
utiliser le <tt>logger</tt>.
</p>
</dd>
<dt>lock</dt><dd><p>
Place un <tt>lock</tt> autour de chaque requête, n&#8217;exécutant donc
qu&#8217;une seule requête par processus Ruby.
</p>
<p>
Activé si votre application n&#8217;est pas <tt>thread-safe</tt>.
Désactivé par défaut.
</p>
</dd>
<dt>method_override</dt><dd><p>
utilise la magie de <tt>_method</tt> afin de permettre des formulaires
put/delete dans des navigateurs qui ne le permettent pas.
</p>
</dd>
<dt>port</dt><dd><p>
port à écouter. Utiliser seulement pour le serveur intégré.
</p>
</dd>
<dt>prefixed_redirects</dt><dd><p>
si oui ou non <tt>request.script_name</tt> doit être inséré dans les
redirections si un chemin non absolu est utilisé. Ainsi, <tt>redirect
'/foo'</tt> se comportera comme <tt>redirect to('/foo')</tt>. Désactivé
par défaut.
</p>
</dd>
<dt>public</dt><dd><p>
dossier duquel les fichiers publics sont servis
</p>
</dd>
<dt>reload_templates</dt><dd><p>
si oui ou non les templates doivent être rechargés entre les requêtes.
Activé en mode développement et sur Ruby 1.8.6 (pour compenser un bug
Ruby occasionnant une fuite de mémoire).
</p>
</dd>
<dt>root</dt><dd><p>
dossier racine du projet.
</p>
</dd>
<dt>raise_errors</dt><dd><p>
soulever les erreurs (ce qui arrêtera l&#8217;application).
</p>
</dd>
<dt>run</dt><dd><p>
si activé, <a href="Sinatra.html">Sinatra</a> s&#8217;occupera de
démarrer le serveur, ne pas activer si vous utiliser rackup ou autres.
</p>
</dd>
<dt>running</dt><dd><p>
est-ce que le serveur intégré est en marche ? ne changez pas ce
paramètre !
</p>
</dd>
<dt>server</dt><dd><p>
serveur ou liste de serveurs à utiliser pour le serveur intégré. Par
défaut [&#8216;thin&#8217;, &#8216;mongrel&#8217;, &#8216;webrick&#8217;],
l&#8217;ordre indiquant la priorité.
</p>
</dd>
<dt>sessions</dt><dd><p>
active l&#8217;enregistrement des sessions en utilisant les cookies.
</p>
</dd>
<dt>show_exceptions</dt><dd><p>
affiche la trace de l&#8217;erreur dans le navigateur.
</p>
</dd>
<dt>static</dt><dd><p>
Si oui ou non <a href="Sinatra.html">Sinatra</a> doit s&#8217;occuper de
servir les fichiers statiques. Désactivez si vous utilisez un serveur
capable de le gérer lui même. Le désactiver augmentera la performance.
Activé par défaut.
</p>
</dd>
<dt>views</dt><dd><p>
dossier des vues.
</p>
</dd>
</dl>
<h2>Gérer les erreurs</h2>
<p>
Les gestionnaires d&#8217;erreur s&#8217;exécutent dans le même contexte
que les routes ou les filtres, ce qui veut dire que vous avez accès (entre
autres) aux bons vieux <tt>haml</tt>, <tt>erb</tt>, <tt>halt</tt>, etc.
</p>
<h3>Pas Trouvé</h3>
<p>
Quand une exception <tt>Sinatra::NotFound</tt> est soulevée, ou que le
code retour est 404, le gestionnaire <tt>not_found</tt> est invoqué:
</p>
<pre>
  not_found do
    'Pas moyen de trouver ce que vous cherchez'
  end
</pre>
<h3>Erreur</h3>
<p>
Le gestionnaire <tt>error</tt> est invoqué à chaque fois qu&#8217;une
exception est soulevée dans une route ou un filtre. L&#8217;objet
exception est accessible via la variable Rack <tt>sinatra.error</tt>:
</p>
<pre>
  error do
    'Désolé mais une méchante erreur est survenue - ' + env['sinatra.error'].name
  end
</pre>
<p>
Erreur sur mesure:
</p>
<pre>
  error MonErreurSurMesure do
    'Donc il est arrivé ceci...' + env['sinatra.error'].message
  end
</pre>
<p>
Donc si ceci arrive:
</p>
<pre>
  get '/' do
    raise MonErreurSurMesure, 'quelque chose de mal'
  end
</pre>
<p>
Vous obtenez ça:
</p>
<pre>
  Donc il est arrivé ceci... quelque chose de mal
</pre>
<p>
Alternativement, vous pouvez avoir un gestionnaire d&#8217;erreur associé
à un code particulier:
</p>
<pre>
  error 403 do
    'Accès interdit'
  end

  get '/secret' do
    403
  end
</pre>
<p>
Ou un intervalle:
</p>
<pre>
  error 400..510 do
    'Boom'
  end
</pre>
<p>
<a href="Sinatra.html">Sinatra</a> installe pour vous quelques
gestionnaires <tt>not_found</tt> et <tt>error</tt> génériques lorsque
vous êtes en environnement <tt>development</tt>.
</p>
<h2>Les Middlewares Rack</h2>
<p>
<a href="Sinatra.html">Sinatra</a> tourne avec <a
href="http://rack.rubyforge.org/">Rack</a>, une interface standard et
minimale pour les web frameworks Ruby. Un des points forts de Rack est le
support de ce que l&#8217;on appelle des &#8220;middlewares&#8221; &#8212;
composant qui vient se situer entre le serveur et votre application, et
dont le but est de visualiser/manipuler la requête/réponse HTTP, et
d&#8217;offrir diverses fonctionnalités classiques.
</p>
<p>
<a href="Sinatra.html">Sinatra</a> permet de construire facilement des
middlewares Rack via la méthode de haut niveau <tt>use</tt>:
</p>
<pre>
  require 'sinatra'
  require 'mon_middleware_perso'

  use Rack::Lint
  use MonMiddlewarePerso

  get '/bonjour' do
    'Bonjour Monde'
  end
</pre>
<p>
La sémantique de <tt>use</tt> est identique à celle définie dans le DSL
de <a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
(le plus souvent utilisé dans un fichier rackup). Par exemple, la méthode
<tt>use</tt> accepte divers arguments ainsi que des blocs:
</p>
<pre>
  use Rack::Auth::Basic do |login, password|
    login == 'admin' &amp;&amp; password == 'secret'
  end
</pre>
<p>
Rack est distribué avec une bonne variété de middlewares standards pour
les logs, débuguer, faire du routage URL, de l&#8217;authentification,
gérer des sessions. <a href="Sinatra.html">Sinatra</a> utilise beaucoup de
ces composants automatiquement via la configuration, donc pour ceux-ci vous
n&#8217;aurez pas à utiliser la méthode <tt>use</tt>.
</p>
<h2>Tester</h2>
<p>
Les tests pour <a href="Sinatra.html">Sinatra</a> peuvent être écrit avec
n&#8217;importe quelle bibliothèque basée sur Rack. <a
href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> est recommandé:
</p>
<pre>
  require 'mon_application_sinatra'
  require 'test/unit'
  require 'rack/test'

  class MonTest &lt; Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_ma_racine
      get '/'
      assert_equal 'Bonjour Monde!', last_response.body
    end

    def test_avec_des_parametres
      get '/rencontrer', :name =&gt; 'Frank'
      assert_equal 'Salut Frank!', last_response.body
    end

    def test_avec_rack_env
      get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
      assert_equal &quot;Vous utilisez Songbird!&quot;, last_response.body
    end
  end
</pre>
<p>
NOTE: Le module intégré Sinatra::Test et la classe Sinatra::TestHarness
sont désapprouvés depuis la version 0.9.2 .
</p>
<h2><a href="Sinatra/Base.html">Sinatra::Base</a> - Les Middlewares, les Bibliothèques, et les Applications Modulaires</h2>
<p>
Définir votre application au niveau supérieur fonctionne bien pour les
micro-applications, mais peut s&#8217;avérer moins pratique
lorsqu&#8217;il s&#8217;agit de créer des composants réutilisables comme
des middlewares Rack, faire du Rails metal, ou de simples bibliothèques
avec un composant serveur, ou même une extension pour <a
href="Sinatra.html">Sinatra</a>. Le DSL de haut niveau pollue
l&#8217;espace de noms et est une configuration adaptée à une
micro-application (un fichier unique pour l&#8217;application, les dossiers
./public et ./views, les logs, pages d&#8217;erreur, etc.). C&#8217;est là
que <a href="Sinatra/Base.html">Sinatra::Base</a> entre en jeu:
</p>
<pre>
  require 'sinatra/base'

  class MonApplication &lt; Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Bonjour Monde!'
    end
  end
</pre>
<p>
Les méthodes disponibles dans <a
href="Sinatra/Base.html">Sinatra::Base</a> sont exactement identiques à
celles disponibles dans le DSL de haut niveau. La plupart des applications
de haut niveau peuvent être converties en composant <a
href="Sinatra/Base.html">Sinatra::Base</a> avec deux modifications:
</p>
<ul>
<li><p>
Votre fichier doit charger <tt>sinatra/base</tt> au lieu de
<tt>sinatra</tt>; autrement, toutes les méthodes de la DSL seront
chargées dans l&#8217;espace
</p>
<pre>
      de noms.
</pre>
</li>
<li><p>
Mettre vos gestionnaires de route, vos gestionnaires d&#8217;erreur, vos
filtres
</p>
<pre>
      et options dans une sous-classe de Sinatra::Base.
</pre>
</li>
</ul>
<p>
<tt>Sinatra::Base</tt> est plutôt épuré. La plupart des options sont
désactivées par défaut, ceci inclus le serveur. Voir <a
href="http://sinatra.github.com/configuration.html">Options et
Configuration</a> pour plus de détails sur les options et leur
comportement.
</p>
<h3>Style modulaire vs. style classique</h3>
<p>
Contrairement aux croyanaces, le style classique n&#8217;a rien de mauvais.
Si cela convient à votre application, vous n&#8217;avez pas à changer
pour une application modulaire.
</p>
<p>
Il n&#8217;y a que deux inconvénient au style classique comparé au style
modulaire :
</p>
<ul>
<li><p>
Vous ne pouvez avoir qu&#8217;une seule application <a
href="Sinatra.html">Sinatra</a> par processus Ruby. Si vous envisagez
d&#8217;en utiliser plus, passez au style modulaire
</p>
</li>
<li><p>
Le style classique pollue  la classe Object avec des méthodes
déléguantes. Si vous prévoyez de diffuser votre application dans une
bibliothèque/gem, passez au style modulaire.
</p>
</li>
</ul>
<p>
Il n&#8217;y pas d&#8217;empêchement à mélanger style classic et style
modulaire.
</p>
<p>
Si vous passez d&#8217;un style à l&#8217;autre, vous devriez être
vigilant à quelques légères différences dans les paramètres :
</p>
<pre>
  Paramètre           Classique                     Modulaire

  app_file            fichier chargeant sinatra     nil
  run                 $0 == app_file                false
  logging             true                          false
  method_override     true                          false
  inline_templates    true                          false
</pre>
<h3>Servir une application modulaire</h3>
<p>
Il y a deux façons de faire pour démarrer une application modulaire,
démarrez avec <tt>run!</tt> :
</p>
<pre>
  # my_app.rb
  require 'sinatra/base'

  class MyApp &lt; Sinatra::Base
    # ... code de l'application ici ...

    # démarre le serveur si ce fichier est directement exécuté
    run! if app_file == $0
  end
</pre>
<p>
Démarrez ensuite avec :
</p>
<pre>
  ruby my_app.rb
</pre>
<p>
Ou alors avec un fichier <tt>config.ru</tt>, qui permet d&#8217;utiliser
n&#8217;importe quel gestionnaire Rack :
</p>
<pre>
  # config.ru
  require 'my_app'
  run MyApp
</pre>
<p>
Exécutez :
</p>
<pre>
  rackup -p 4567
</pre>
<h3>Utiliser une application de style classique avec un fichier config.ru</h3>
<p>
Ecrivez votre application :
</p>
<pre>
  # app.rb
  require 'sinatra'

  get '/' do
    'Hello world!'
  end
</pre>
<p>
Et un fichier <tt>config.ru</tt> correspondant :
</p>
<pre>
  require 'app'
  run Sinatra::Application
</pre>
<h3>Quand utiliser un fichier config.ru ?</h3>
<p>
Quelques cas où vous devriez utiliser un fichier <tt>config.ru</tt> :
</p>
<ul>
<li><p>
Vous souhaitez déployer avec un autre gestionnaire Rack (Passenger,
Unicorn, Heroku, &#8230;).
</p>
</li>
<li><p>
Vous souhaitez utiliser plus d&#8217;une sous-classe de
<tt>Sinatra::Base</tt>.
</p>
</li>
<li><p>
Vous voulez utiliser <a href="Sinatra.html">Sinatra</a> comme un
<tt>middleware</tt>, non en tant que <tt>endpoint</tt>.
</p>
</li>
</ul>
<p>
<b>Il n&#8217;est pas nécessaire de passer par un fichier
<tt>config.ru</tt> pour la seule raison que vous êtes passé au style
modulaire, et vous n&#8217;avez pas besoin de passer au style modulaire
pour utiliser un fichier <tt>config.ru</tt>.</b>
</p>
<h3>Utiliser <a href="Sinatra.html">Sinatra</a> comme Middleware</h3>
<p>
Non seulement <a href="Sinatra.html">Sinatra</a> peut utiliser
d&#8217;autres middlewares Rack, il peut également être à son tour
utilisé au-dessus de n&#8217;importe quel <tt>endpoint</tt> Rack en tant
que middleware. Ce <tt>endpoint</tt> peut très bien être une autre
application <a href="Sinatra.html">Sinatra</a>, ou n&#8217;importe quelle
application basée sur Rack (Rails/Ramaze/Camping/...):
</p>
<pre>
  require 'sinatra/base'

  class EcranDeConnexion &lt; Sinatra::Base
    enable :sessions

    get('/connexion') { haml :connexion }

    post('/connexion') do
      if params[:nom] = 'admin' and params[:motdepasse] = 'admin'
        session['nom_utilisateur'] = params[:nom]
      else
        redirect '/connexion'
      end
    end
  end

  class MonApp &lt; Sinatra::Base
    # le middleware sera appelé avant les filtres
    use EcranDeConnexion

    before do
      unless session['nom_utilisateur']
        halt &quot;Accès refusé, merci de vous &lt;a href='/connexion'&gt;connecter&lt;/a&gt;.&quot;
      end
    end

    get('/') { &quot;Bonjour #{session['nom_utilisateur']}.&quot; }
  end
</pre>
<h2>Contextes et Binding</h2>
<p>
Le contexte dans lequel vous êtes détermine les méthodes et variables
disponibles.
</p>
<h3>Contexte de l&#8217;application/classe</h3>
<p>
Toute application <a href="Sinatra.html">Sinatra</a> correspond à une
sous-classe de <a href="Sinatra/Base.html">Sinatra::Base</a>. Si vous
utilisez le DSL haut niveau (<tt>require 'sinatra'</tt>), alors cette
classe est <a href="Sinatra/Application.html">Sinatra::Application</a>,
sinon il s&#8217;agit de la sous-classe que vous avez définie. Dans le
contexte de la classe, vous avez accès aux méthodes telles que `get` ou
`before`, mais vous n&#8217;avez pas accès aux objets `request` ou
`session` car c&#8217;est la même classe d&#8217;application qui traitera
toutes les requêtes.
</p>
<p>
Les options définies au moyen de `set` deviennent des méthodes de classe:
</p>
<pre>
    class MonApp &lt; Sinatra::Base
      # Eh, je suis dans le contexte de l'application!
      set :foo, 42
      foo # =&gt; 42

      get '/foo' do
        # Eh, je ne suis plus dans le contexte de l'application!
      end
    end
</pre>
<p>
Vous avez le binding du contexte de l&#8217;application dans:
</p>
<ul>
<li><p>
Le corps de la classe d&#8217;application
</p>
</li>
<li><p>
Les méthodes définies par les extensions
</p>
</li>
<li><p>
Le bloc passé à `helpers`
</p>
</li>
<li><p>
Les procs/blocs utilisés comme argument pour `set`
</p>
</li>
</ul>
<p>
Vous pouvez atteindre ce contexte (donc la classe) de la façon suivante:
</p>
<ul>
<li><p>
Via l&#8217;objet passé dans les blocs `configure` (<tt>configure { |c|
... }</tt>)
</p>
</li>
<li><p>
En utilisant `settings` dans le contexte de la requête
</p>
</li>
</ul>
<h3>Contexte de la requête/instance</h3>
<p>
Pour tout traitement d&#8217;une requête, une nouvelle instance de votre
classe d&#8217;application est créée et tous vos gestionnaires sont
exécutés dans ce contexte. Dans ce dernier, vous pouvez accéder aux
objets `request` et `session` et faire appel aux fonctions de rendu telles
que `erb` ou `haml`. Vous pouvez accéder au contexte de
l&#8217;application depuis le contexte de la requête au moyen de
`settings`:
</p>
<pre>
  class MonApp &lt; Sinatra::Base
    # Eh, je suis dans le contexte de l'application!
    get '/ajouter_route/:nom' do
      # Contexte de la requête pour '/ajouter_route/:nom'
      @value = 42

      settings.get(&quot;/#{params[:nom]}&quot;) do
        # Contexte de la requête pour &quot;/#{params[:nom]}&quot;
        @value # =&gt; nil (on est pas au sein de la même requête)
      end

      &quot;Route ajoutée!&quot;
    end
  end
</pre>
<p>
Vous avez le binding du contexte de la requête dans:
</p>
<ul>
<li><p>
les blocs get/head/post/put/delete/options
</p>
</li>
<li><p>
les filtres before/after
</p>
</li>
<li><p>
les méthodes utilitaires (définies au moyen de `helpers`)
</p>
</li>
<li><p>
les vues/templates
</p>
</li>
</ul>
<h3>Le contexte de délégation</h3>
<p>
Le contexte de délégation se contente de transmettre les appels de
méthodes au contexte de classe. Toutefois, il ne se comporte pas à 100%
comme le contexte de classe car vous n&#8217;avez pas le binding de la
classe: seules les méthodes spécifiquement déclarées pour délégation
sont disponibles et il n&#8217;est pas possible de partager des
variables/états avec le contexte de classe (comprenez: `self` n&#8217;est
pas le même). Vous pouvez ajouter des délégation de méthodes en
appelant <tt>Sinatra::Delegator.delegate :method_name</tt>.
</p>
<p>
Vous avez le binding du contexte de délégation dans:
</p>
<ul>
<li><p>
Le binding de haut niveau, si vous avez utilisé <tt>require
&quot;sinatra&quot;</tt>
</p>
</li>
<li><p>
Un objet qui inclut le module `Sinatra::Delegator`
</p>
</li>
</ul>
<p>
Jetez un oeil pour vous faire une idée: voici le mixin <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator</a>
qui est <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">inclus
dans l'espace de noms principal</a>
</p>
<h2>Ligne de commande</h2>
<p>
Les applications en <a href="Sinatra.html">Sinatra</a> peuvent être
lancées directement:
</p>
<pre>
  ruby mon_application.rb [-h] [-x] [-e ENVIRONNEMENT] [-p PORT] [-o HOTE] [-s SERVEUR]
</pre>
<p>
Les options sont:
</p>
<pre>
  -h # aide
  -p # déclare le port (4567 par défaut)
  -o # déclare l'hôte (0.0.0.0 par défaut)
  -e # déclare l'environnement (+development+ par défaut)
  -s # déclare le serveur/gestionnaire à utiliser (thin par défaut)
  -x # active le mutex lock (off par défaut)
</pre>
<h2>Configuration nécessaire</h2>
<p>
Il est recommandé d&#8217;installer <a href="Sinatra.html">Sinatra</a> sur
Ruby 1.8.7, 1.9.2, JRuby ou Rubinius.
</p>
<p>
Les versions suivantes de Ruby sont officiellement supportées :
</p>
<dl>
<dt> Ruby 1.8.6 </dt><dd><p>
Il n&#8217;est pas recommandé d&#8217;utiliser 1.8.6 pour <a
href="Sinatra.html">Sinatra</a>. Toutefois, ce sera officiellement
supporté jusqu&#8217;à l&#8217;arrivée <a
href="Sinatra.html">Sinatra</a> 1.3.0. Les templates RDoc et CoffeeScript
ne sont pas supportés par cette version de Ruby. 1.8.6 contient un défaut
majeur de fuite de mémoire dans l&#8217;implémentation de Hash, qui est
déclenché par les versions de <a href="Sinatra.html">Sinatra</a>
antérieure à 1.1.1. La version actuelle prévient explicitement ce risque
au prix de la performance. Vous devrez utiliser Rack 1.1.x dans la mesure
où Rack >= 1.2 ne supporte plus 1.8.6.
</p>
</dd>
<dt> Ruby 1.8.7 </dt><dd><p>
1.8.7 est complètement supporté, toutefois si rien ne vous y retient,
nous vous recommandons de passer à 1.9.2 ou bien de passer à JRuby ou
Rubinius.
</p>
</dd>
<dt> Ruby 1.9.2 </dt><dd><p>
1.9.2 est supporté et recommandé. Notez que Radius et Markaby ne sont
actuellement pas compatible avec 1.9. N&#8217;utilisez pas 1.9.2p0 qui est
réputé causer des erreurs de segmentation lorque <a
href="Sinatra.html">Sinatra</a> est utilisé.
</p>
</dd>
<dt> Rubinius </dt><dd><p>
Rubinius est officiellement supporté (Rubinius >= 1.2.2), à
l&#8217;exception des templates Textile.
</p>
</dd>
<dt> JRuby </dt><dd><p>
JRuby est officiellement supporté (JRuby >= 1.5.6). Aucune anomalie avec
des bibliothèques de templates tierces ne sont connues. Toutefois, si vous
choisissez JRuby, alors tournez vous vers des gestionnaires Rack JRuby car
le serveur Thin n&#8217;est pas (encore) supporté par JRuby.
</p>
</dd>
</dl>
<p>
Nous gardons également un oeil sur les versions Ruby à venir.
</p>
<p>
Les implémentations Ruby suivantes ne sont pas officiellement supportées
mais sont toujours connues comme permettant à <a
href="Sinatra.html">Sinatra</a> de fonctionner :
</p>
<ul>
<li><p>
Plus anciennes versions de JRuby et Rubinius
</p>
</li>
<li><p>
MacRuby
</p>
</li>
<li><p>
Maglev
</p>
</li>
<li><p>
IronRuby
</p>
</li>
<li><p>
Ruby 1.9.0 et 1.9.1
</p>
</li>
</ul>
<p>
Ne pas être officiellement supporté signifie que si les choses se passent
mal sur ces plateformes et non sur celles supportées, nous considérons
que l&#8217;anomalie est de le ressort, pas du nôtre.
</p>
<p>
<a href="Sinatra.html">Sinatra</a> devrait fonctionner sur n&#8217;importe
quel système d&#8217;exploitation supportant l&#8217;implémentation Ruby
choisie.
</p>
<h2>Essuyer les plâtres</h2>
<p>
Si vous voulez utiliser la toute dernière version de <a
href="Sinatra.html">Sinatra</a>, n&#8217;ayez pas peur de faire tourner
votre application sur la branche master, cela devrait être stable.
</p>
<p>
Nous publions également une gem de <tt>prerelease</tt> de temps en temps
donc vous pouvez faire la chose suivante :
</p>
<pre>
  gem install sinatra --pre
</pre>
<p>
afin d&#8217;avoir certaines des toutes dernières fonctionnalités.
</p>
<h3>Avec Bundler</h3>
<p>
Si vous voulez faire tourner votre application avec le tout dernier <a
href="Sinatra.html">Sinatra</a>, <a
href="http://gembundler.com/">Bundler</a> est recommandé.
</p>
<p>
Tout d&#8217;abord, installer bundler si vous ne l&#8217;avez pas :
</p>
<pre>
  gem install bundler
</pre>
<p>
Ensuite, dans le dossier de votre projet, créez un fichier
<tt>Gemfile</tt> :
</p>
<pre>
  source :rubygems
  gem 'sinatra', :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;

  # autres dépendances
  gem 'haml'                    # par exemple, si vous utilisez haml
  gem 'activerecord', '~&gt; 3.0'  # peut-être que vous avez également besoin
                                # de ActiveRecord 3.x
</pre>
<p>
Notez que vous aurez à lister toutes les dépendances de votre application
dans ce fichier. Les dépendances directes de <a
href="Sinatra.html">Sinatra</a> (Rack et Tilt) seront automatiquement
téléchargées et ajoutées par Bundler.
</p>
<p>
Maintenant, vous pouvez faire tourner votre application de la façon
suivante :
</p>
<pre>
  bundle exec ruby myapp.rb
</pre>
<h3>Faites le vous-même</h3>
<p>
Créez un clone local et démarrez votre application avec le dossier
<tt>sinatra/lib</tt> dans le <tt>$LOAD_PATH</tt> :
</p>
<pre>
  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb
</pre>
<p>
A l&#8217;avenir, pour mettre à jour le code source de <a
href="Sinatra.html">Sinatra</a> :
</p>
<pre>
  cd myapp/sinatra
  git pull
</pre>
<h3>Installez globalement</h3>
<p>
Vous pouvez construire la gem vous-même :
</p>
<pre>
  git clone git://github.com/sinatra/sinatra.git
  cd sinatra
  rake sinatra.gemspec
  rake install
</pre>
<p>
Si vous installez les gems en tant que <tt>root</tt>, la dernière étape
sera :
</p>
<pre>
  sudo rake install
</pre>
<h2>Versions</h2>
<p>
<a href="Sinatra.html">Sinatra</a> se conforme aux <a
href="http://semver.org/">versions sémantiques</a>, aussi bien SemVer que
SemVerTag.
</p>
<h2>Mais encore</h2>
<ul>
<li><p>
<a href="http://www.sinatrarb.com/">Site internet</a> - Plus de
documentation, de news, et des liens vers d&#8217;autres ressources.
</p>
</li>
<li><p>
<a href="http://www.sinatrarb.com/contributing">Contribuer</a> - Vous avez
trouvé un bug? Besoin d&#8217;aide? Vous avez un patch?
</p>
</li>
<li><p>
<a href="http://github.com/sinatra/sinatra/issues">Suivi des problèmes</a>
</p>
</li>
<li><p>
<a href="http://twitter.com/sinatra">Twitter</a>
</p>
</li>
<li><p>
<a href="http://groups.google.com/group/sinatrarb/topics">Mailing List</a>
</p>
</li>
<li><p>
<a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> sur <a
href="http://freenode.net">freenode.net</a>
</p>
</li>
</ul>

	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>
</body>
</html>

